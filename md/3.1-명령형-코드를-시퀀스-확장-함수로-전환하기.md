## 3.1 명령형 코드를 시퀀스 확장 함수로 전환하기

1장과 2장에서는 이터러블과 이터레이터, 그리고 시퀀스에 대해 다뤘습니다. 이번 절에서는 실제로 일상에서 마주칠 만한 문제들을 해결하는 로직을 함수형으로 작성하면서, 그동안의 이야기를 실질적인 세계로 가져오려고 합니다. 그 시작은 명령형 코드를 리스트 프로세싱 함수로 대체하는 것입니다.

### 3.1.1 [for, i++, if, break] - 코드를 리스트로 생각하기 

코드를 리스트로 바라보는 사고방식은 프로그래밍 패러다임을 확장하는 강력한 도구입니다. 함수형 프로그래밍에서는 코드가 곧 데이터이고, 데이터가 곧 코드인 특성을 이용하여 더 읽기 쉽고 유지보수하기 좋은 코드를 작성할 수 있습니다. 이번 섹션에서는 `for`, `i++`, `if`, `break`와 같은 명령형 코드들을 함수형 리스트 프로세싱 함수들로 변경하면서, 코드가 리스트로 어떻게 처리될 수 있는지를 탐구해보겠습니다.

#### 명령형으로 작성한 n개의 홀수를 제곱하여 모두 더하는 함수

[코드 3-1]은 n개의 홀수를 제곱하여 모두 더하는 함수입니다. 코드를 실행하면 `list` 배열에서 처음 3개의 홀수(1, 3, 5)를 선택하고, 각 홀수의 제곱(1^2, 3^2, 5^2)을 계산하여 더합니다. 최종 합계인 `1 + 9 + 25 = 35`가 출력됩니다.

##### [코드 3-1] limit개의 홀수를 제곱하여 모두 더하기

```kotlin
fun sumOfSquaresOfOddNumbers(limit: Int, list: List<Int>): Int {
    var acc = 0
    var remaining = limit
    for (a in list) {
        if (a % 2 == 1) {
            val b = a * a
            acc += b
            if (--remaining == 0) break
        }
    }
    return acc
}

fun main() {
    println(sumOfSquaresOfOddNumbers(3, listOf(1, 2, 3, 4, 5, 6, 7, 8, 9)))
    // 35
}
```

이 코드가 하는 일은 다음과 같이 정리할 수 있습니다.

1. 순회: `for (a in list)`로 `list`의 각 요소를 순회합니다.
2. 홀수 검사: `if (a % 2 == 1)`로 홀수인지 확인합니다.
3. 제곱 계산: `val b = a * a`로 홀수라면 제곱합니다.
4. 누적 합계 갱신: `acc += b`로 누적 변수에 더합니다.
5. 길이 검사 및 종료: `--remaining` 후 `if (--remaining == 0) break`로 필요한 만큼만 처리합니다.
6. 결과 반환: `return acc`로 누적 합계 반환

#### if를 filter로

`if` 조건문은 `filter` 함수로 대체할 수 있습니다.

##### [코드 3-2] if를 filter로

```kotlin
fun sumOfSquaresOfOddNumbers(limit: Int, list: List<Int>): Int {
    var acc = 0
    var remaining = limit
    for (a in list.filter { it % 2 == 1 }) {
        val b = a * a
        acc += b
        if (--remaining == 0) break
    }
    return acc
}
```

- `list.filter { it % 2 == 1 }`를 통해 홀수만 남긴 새로운 리스트를 얻습니다.
- 그러면 `for` 문 내부에서는 이미 필터링된 요소만 다루므로, 별도의 `if`가 필요 없어집니다.

이 예제에서는 `list`에서 `a`를 뽑아 `if (a % 2 == 1) {}`로 코드의 실행을 제어하던 **코드 문장**이 `filter`가 적용된 **리스트**로 대체되었습니다. `for` 문의 내부 코드 입장에서는 `a`가 필터링된 결과인지 아닌지 알 필요가 없고, 그저 요소인 `a`를 제곱하고 합산하는 일만 합니다.

다시 한 번 정리하면 다음과 같습니다.

1. 곳곳에 있던 **코드 문장**이 **리스트 프로세싱 함수 실행**으로 대체되었습니다.
2. `filter { it % 2 == 1 }`는 필터 로직을 수행하는 **코드**인 동시에 **리스트**입니다.
3. 내부 로직에서 조건문이 제거되어, 코드가 더욱 명확하고 단순해졌습니다.

> **참고:**  
> 여기서 `it`은 코틀린 람다식에서 인자가 하나일 때 쓰이는 암시적(implicit) 파라미터입니다.  
> 예를 들어, `filter { it % 2 == 1 }`는 사실상 `filter { x -> x % 2 == 1 }`와 같은 의미입니다.  
> `it` 대신 직접 인자 이름(`x`, `num` 등)을 지정하려면 `filter { num -> num % 2 == 1 }`와 같이 사용할 수 있습니다.

#### 값 변화 후 변수 할당을 map으로

이 절에서는 예제들을 통해 코드의 전체적인 구조를 건드리지 않으면서, 점진적으로 함수형으로 리팩토링하는 방법도 함께 익히고 있습니다. 이번에는 `map`을 활용하여, 값 변화 후 변수 할당을 제거하도록 해보겠습니다.

##### [코드 3-3] map이 대체한 코드

```kotlin
fun sumOfSquaresOfOddNumbers(limit: Int, list: List<Int>): Int {
    var acc = 0
    var remaining = limit
    for (b in list.filter { it % 2 == 1 }.map { it * it }) {
        acc += b
        if (--remaining == 0) break
    }
    return acc
}
```

- `list.filter { ... }.map { ... }`는 홀수만 남긴 뒤 각각을 제곱한 새로운 리스트를 리턴합니다.
- 따라서 `for` 문 안에서는 이미 제곱된 값만 순회하므로, `b = a * a` 같은 변수가 사라집니다.

역시 코드 문장들이 리스트와 함수들의 조합으로 변경되고 있습니다. 이 느낌을 보다 효과적으로 전달하기 위해, 이 코드를 LISP 문법으로 표현하여 설명하면 더 좋을 것 같습니다. LISP 문법이 코드를 리스트로 다루는 컨셉을 더 잘 나타내기 때문입니다.

[코드 3-4]는 LISP 계열 언어인 Scheme으로 작성한 코드입니다.

##### [코드 3-4] Scheme 코드

```scheme
; Scheme
(define list '(1 2 3 4 5))

(define (square x) (* x x))

(map square (filter odd? list))
; (1 9 25)

; Kotlin
; listOf(1, 2, 3, 4, 5).filter { it % 2 == 1 }.map { it * it }
```

[코드 3-4]에서 보면 `list`를 생성하고 있는 `'(1 2 3 4 5)`와 같은 문법과 곱하기 연산자(`*`)로 `x`의 제곱을 구하는 `(* x x)`와 같은 문법이 작은 따옴표(`'`)[^6]를 빼고는 동일함을 볼 수 있습니다. 그러니까 LISP에서는 숫자 배열과 같은 데이터를 정의하는 문법도 리스트로 표현되며, 제곱을 하는 계산식 또한 리스트로 표현됩니다. 다시 말해 함수의 호출 또한 리스트로 표기되며 `(* x x)`라는 리스트는 `*` 하나와 `x` 두 개를 가지며, 리스트인 코드를 평가했을 때 `x`의 제곱으로 계산됩니다.

같은 시각으로 `(filter odd? list)`를 보면 `filter`와 `odd?`와 `list`가 들어 있는 리스트이고, `list`가 `(1 2 3 4 5)`이기에, `(filter odd? list)`는 결과적으로 `(filter odd? '(1 2 3 4 5))`와 같이 중첩된 리스트입니다. `(map square (filter odd? list))` 도 [코드 3-4a]와 같이 여러 단계로 중첩된 리스트입니다.

##### [코드 3-4a] Scheme 코드

```scheme
(map (lambda (x) (* x x)) (filter odd? '(1 2 3 4 5)))
```

LISP에서는 이 리스트이자 코드이자 데이터를 평가하는 식으로 프로그램이 실행되며, 리스트는 코드이고, 코드는 리스트이며, 중첩된 리스트는 알고리즘이자 로직입니다. LISP의 문법은 이러한 LISP의 철학을 잘 반영하며, 더 우아하게 표현해내는 것 같습니다.

이 책에서 주 언어로 사용하고 있는 타입스크립트는 LISP과 문법만 약간 다를뿐, 이터러블과 이터레이터를 활용한 이터레이션 프로토콜을 기반하여 이러한 패러다임을 그대로 적용할 수 있고, 지금까지의 예제들은 그것들을 잘 보여주고 있습니다.

#### break를 take로

이제 `if (--limit === 0) break;` 부분을 `take`로 대체해보겠습니다.

##### [코드 3-5] take가 대체한 코드

```kotlin
fun sumOfSquaresOfOddNumbers(limit: Int, list: List<Int>): Int {
    var acc = 0
    for (a in list.asSequence()
        .filter { it % 2 == 1 }
        .map { it * it }
        .take(limit)) {
        acc += a
    }
    return acc
}
```

- `take(limit)`를 통해 필요한 개수만큼 요소를 평가하므로, 더 이상 `break`가 필요 없습니다.
- `var remaining = limit`, `if (--remaining == 0) break`가 제거 되었습니다.
- 지연 시퀀스(`asSequence()`)를 사용해 필요한 만큼만 처리되므로, 성능상도 문제가 없으며, 명령형 코드와 동일한 효율입니다.

이 코드에서는 반복문을 빠져나가는 `break`문을 제거했음에도 시간복잡도가 동일하다는 사실에 주목해야합니다. `break`는 필요한 만큼만 코드가 반복되도록 제어하여 로직의 효율성을 높이는 키워드입니다. 여기서 `take`를 통해 `break` 같은 제어문마저도 **리스트로 사고**할 수 있음을 확인했습니다. 이러한 접근을 가능하게 하는 핵심은 지연 평가이며, 이에 대해서는 '3.3 지연 평가 자세히 보기'에서 더욱 알아보겠습니다.

### 합산을 fold 혹은 reduce로

이제 남은 명령형 코드를 보니 사실상 `fold`의 구현과 거의 같습니다. 마지막으로 `acc`를 업데이트하는 과정을 `fold`로 대체합니다.

##### [코드 3-6] fold로 대체하기

```kotlin
fun sumOfSquaresOfOddNumbers(limit: Int, list: List<Int>): Int =
    list.asSequence()
        .filter { it % 2 == 1 }
        .map { it * it }
        .take(limit)
        .fold(0) { a, b -> a + b }

fun main() {
    println(sumOfSquaresOfOddNumbers(3, listOf(1, 2, 3, 4, 5, 6, 7, 8, 9)))
    // 35
}
```

- `fold(0) { a, b -> a + b }`는 모든 요소를 순회하며 누적합을 계산한 최종 결과를 반환합니다.
- 이제 명령형의 `acc` 변수를 직접 관리하지 않아도 되므로, 코드가 훨씬 간결해집니다.
- 또한, 코드가 문장 형태가 아니기 때문에 단일 표현식 함수로 변경할 수 있습니다.

명령형 코드에 존재하던 조건문, 변수 할당, 반복문, break 등을 각각의 함수형 API(`filter`, `map`, `take`, `fold`)로 단계적으로 분리하여 "어떤 작업"을 하는지를 명확히 선언합니다. 이러한 선언적 코드를 읽으면, 위에서부터 아래로 "홀수 필터 → 제곱 → 일부만 취하기 → 합산"이라는 흐름이 직관적으로 드러납니다. 덕분에 유지보수가 편리해지고, 부분적인 변경이나 재사용도 훨씬 쉬워집니다.

### 3.1.2 리스트 프로세싱 패러다임과 현대 프로그래밍

정리하자면, 명령형으로 작성된 `sumOfSquaresOfOddNumbers`는 내부적으로 다음 로직을 담고 있었습니다.

1. 순회: `for (a in list)`를 통해 `list` 배열의 각 요소를 순회합니다. `a`는 배열의 현재 요소입니다.
2. 홀수 검사: `if (a % 2 == 1)` 조건문을 사용하여 `a`가 홀수인지 검사합니다. 홀수인 경우에만 다음 단계를 실행합니다.
3. 제곱 계산: `val b = a * a` 를 통해 홀수 `a`의 제곱을 계산하여 `b`에 저장합니다.
4. 누적 합계 갱신: `acc += b`를 통해 누적 합계에 `b`를 더합니다.
5. 길이 검사 및 종료: `if (--remaining == 0) break` 조건문을 사용하여 `remaining`를 감소시키고, `remaining`가 0이 되면 반복문을 종료합니다.
6. 결과 반환: `return acc` 를 통해 최종 누적 합계를 반환합니다.

이 코드를 함수형으로 전환하면 다음과 같은 리스트 프로세싱 단계로 대응됩니다.

1. 순회: `list.asSequence()`로 순회할 지연 시퀀스를 만듭니다.
2. 홀수 검사: `filter { it % 2 == 1 }`로 홀수만 남길 지연된 리스트를 만듭니다.
3. 제곱 계산: `map { it * it }`으로 필터가 적용된 이터레이터의 요소에 제곱 적용을 추가한 지연된 리스트를 만듭니다.
4. 길이 검사 및 종료: `take(limit)`만큼만 순회될 지연된 리스트를 만듭니다.
5. 누적 합계 갱신: `fold(0) { a, b -> a + b }`로 모든 요소를 처음 뽑아내면서 더합니다.
6. 결과 반환: `= ((()))` 단일 표현식으로 중첩된 리스트를 평가하여 누적 합계를 반환합니다.

결국 리스트가 중첩되어 있는 것과 다름없습니다.

- 첫 번째 리스트: 원본 리스트 (`list`)
- 두 번째 리스트: 홀수만 남긴 리스트 (`filter`)
- 세 번째 리스트: 홀수를 제곱한 리스트 (`map`)
- 네 번째 리스트: 앞의 결과 중 `limit`개만 노출하는 리스트 (`take`)
- 마지막 단계: 그 리스트의 모든 요소를 더하는 `fold`

리스트 프로세싱은 이처럼 (명령형) 코드 라인들을 리스트로 만듭니다. 코드를 값(리스트)으로 다루고, 함수를 값(일급 함수)으로 다루어, 작은 코드들의 목록으로 복잡한 문제를 해결해나가는 것, 이것이 함수형 프로그래밍과 리스트 프로세싱의 방법입니다. 이 접근 방식은 코드의 각 부분을 독립적인 리스트 요소로 취급하여 복잡한 로직을 세분화하여 정복하는 방법을 제시합니다. 결과적으로 리스트 프로세싱으로 구현된 코드는 더 읽기 쉽고, 유지보수하기 쉬워지며, 각 부분의 역할이 명확해집니다.

이 절에서 살펴본 이터레이터에 기반한 이터레이션 프로토콜과 헬퍼 함수 세트들은 대부분의 현대 프로그래밍 언어에서 지원하고 있는 기능이자 개념입니다. Kotlin, Java, Scala, Swift, JavaScript, TypeScript, Clojure, Scala, C# 등 다양한 언어는 각기 고유한 이터레이션 프로토콜이나 유사한 메커니즘을 바탕으로 지연 평가를 지원합니다. 언어 차원에서 고수준의 함수형 프로그래밍을 지원함으로써 개발자는 코드 가독성과 유지보수성을 높이고, 데이터 처리 효율을 극대화할 수 있습니다.

결국 객체 지향, 명령형, 함수형 패러다임을 결합한 멀티패러다임적 사고와 문제 해결 능력은 특정 언어에 국한되지 않습니다. 현대 프로그래밍 언어들은 강력한 타입 시스템과 타입 추론을 지원하고 클래스와 인터페이스, 이터레이션 프로토콜, 함수형 고차 함수를 모두 활용할 수 있습니다. 이 책에서 다루는 개념과 원칙 역시 이러한 언어 전반에 적용 가능하며, 다양한 환경에서 더 안전하고 효율적인 코드를 구현하는 데 기여할 것입니다.

