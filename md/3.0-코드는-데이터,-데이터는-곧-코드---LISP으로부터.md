# 3. 코드는 데이터, 데이터는 곧 코드 - LISP으로부터

반복문과 조건문, 변수 재할당처럼 우리가 평소 사용하는 명령형 코드는 사실상 "리스트(list)" 형태의 데이터로도 표현될 수 있습니다. "코드는 데이터이고, 데이터는 곧 코드"라는 말은, 특히 LISP 계열 언어에서 매우 중요한 철학으로 자리 잡아, 프로그램 로직을 리스트로 구성하고 이를 곧바로 평가(evaluate)하여 실행하는 방식에 잘 드러납니다. 이번 장에서는 이러한 관점을 도입해, 우리가 일상적으로 작성하던 명령형 코드를 리스트 프로세싱과 함수형 스타일로 전환하는 과정을 구체적으로 살펴봅니다.

먼저 1·2장에서 다뤘던 이터레이션 개념을 바탕으로, "명령형 반복 구조와 조건 로직"을 어떻게 리스트와 함수로 치환할 수 있는지를 탐구합니다. 필터(`filter`), 맵(`map`), 테이크(`take`), 리듀스(`reduce`) 같은 시퀀스 확장 함수를 활용하면, 기존에 `for`, `if`, `break` 등에 의존하던 구문들을 훨씬 더 선언적으로 표현할 수 있습니다. 이를 통해 코드를 읽고 쓰는 방식을 "조건을 만족하는 데이터를 통과시켜 변환하고, 필요한 개수만큼만 소비한다"라는 리스트 프로세싱 시점으로 전환하게 될 것입니다.

또한 코틀린의 확장 함수를 활용해 언어 기능을 확장하는 기법과, 시퀀스 체인에서 함수형과 명령형 로직을 자유롭게 섞는 방법도 살펴봅니다. 이어서 지연 평가의 내부 동작을 파헤치고, 실제 업무에서도 자주 마주칠 법한 데이터 세트나 로직을 코틀린이 제공하는 풍부한 리스트 프로세싱 기능으로 구현해보며, 함수형 접근이 가져다주는 가독성과 생산성을 체감해봅니다.