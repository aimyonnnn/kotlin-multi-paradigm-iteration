# 코틀린 멀티패러다임 이터레이션

### 본서 『멀티패러다임 프로그래밍』 소개

<a href="https://product.kyobobook.co.kr/detail/S000216318962"><img alt="멀티패러다임 프로그래밍" src="../img/book.jpg" width="140px"></a>

> [교보문고](https://product.kyobobook.co.kr/detail/S000216318962) |
[yes24](https://www.yes24.com/product/goods/145367977)
| [알라딘](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=362548794)
> 
> [공식 GitHub](https://github.com/marpple/multi-paradigm-programming)

### 『코틀린 멀티패러다임 이터레이션』 목차

- [지은이의 글](0.1-지은이의-글.md)

1. [이터레이터 - 객체 지향으로부터](1.0-이터레이터---객체-지향으로부터.md)
   1. [이터러블(Iterable)과 이터레이터(Iterator)](1.1-이터러블(Iterable)과-이터레이터(Iterator).md)
      1. 이터러블과 이터레이터의 인터페이스
      2. 이터러블, 이터레이터 기반 순회
   2. [이터레이터(Iterator) - 멀티패러다임 이터레이션의 교차점](1.2-이터레이터(Iterator)---멀티패러다임-이터레이션의-교차점.md)
      1. 객체 지향적으로 구현하는 이터레이터
      2. 반복자 패턴을 사용하는 이유
      3. 이터러블과 확장 함수
2. [시퀀스 빌더 - 명령형으로부터](2.0-시퀀스-빌더---명령형으로부터.md)
   1. [시퀀스(Sequence) 빌더](2.1-시퀀스(Sequence)-빌더.md)
      1. 명령형 스타일로 이터레이터 구현하기 - 시퀀스 빌더
      2. 시퀀스를 반환하는 함수 만들기
      3. 지연 평가 - 시퀀스의 게으른 동작
   2. [이터레이터와 시퀀스, 그리고 이터러블](2.2-이터레이터와-시퀀스,-그리고-이터러블.md)
      1. 이터레이터와 시퀀스
      2. 이터레이터와 시퀀스 상호 변환시 유의할 상황
3. [코드는 데이터, 데이터는 곧 코드 - LISP으로부터](3.0-코드는-데이터,-데이터는-곧-코드---LISP으로부터.md)
   1. [시퀀스 확장 함수 - map, filter, take, reduce](3.1-명령형-코드를-시퀀스-확장-함수로-전환하기.md)
      1. [for, i++, if, break] - 코드를 리스트로 생각하기
      2. 리스트 프로세싱 패러다임과 현대 프로그래밍
   2. [확장 함수(Extension Function) 만들기](3.2-확장-함수(Extension-Function)-만들기.md)
      1. 확장 함수 만들기
      2. 시퀀스에 확장 함수 추가하기
   3. [지연 평가 자세히 보기](3.3-지연-평가-자세히-보기.md)
      1. 중첩된 시퀀스의 내부 실행 순서
      2. 체이닝된 시퀀스의 실행을 다시 보기
   4. [실전 데이터 다루기](3.4-실전-데이터-다루기.md)
      1. 2차원 리스트의 숫자 다루기
      2. 농구 리그 통계
      3. 커머스 데이터 다루기
      4. 커머스 데이터 다루기 2
      5. 일관된 접근 방식으로 문제 해결하기
   5. [더 많은 문제로 확장하기](3.5-더-많은-문제로-확장하기.md)
      1. zip
      2. 인덱스가 값으로 필요할 때 - generateSequence, withIndex, mapIndex
      3. 콜라츠 추측 - 1이 될 때까지 세기
      4. break를 대신하는 take, takeWhile, takeUntilInclusive
